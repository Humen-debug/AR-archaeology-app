diff --git a/node_modules/expo-three-orbit-controls/build/OrbitControls.d.ts b/node_modules/expo-three-orbit-controls/build/OrbitControls.d.ts
index be2f5eb..3ff5c0c 100644
--- a/node_modules/expo-three-orbit-controls/build/OrbitControls.d.ts
+++ b/node_modules/expo-three-orbit-controls/build/OrbitControls.d.ts
@@ -10,6 +10,7 @@
  * @author ScieCode / http://github.com/sciecode
  */
 import { EventDispatcher, MOUSE, TOUCH, Vector3, Camera } from 'three';
+
 export declare class OrbitControls extends EventDispatcher {
     object: Camera & {
         fov: number;
@@ -21,7 +22,167 @@ export declare class OrbitControls extends EventDispatcher {
         updateProjectionMatrix: () => void;
         isOrthographicCamera?: boolean;
         isPerspectiveCamera?: boolean;
-    };
+        
+        /**
+         * The focus point of the controls, the .object orbits around this.
+         * It can be updated manually at any point to change the focus
+         * of the controls.
+         */
+        target?: Vector3;
+
+        /**
+         * How far you can dolly in ( PerspectiveCamera only ).
+         * @default 0
+         */
+        minDistance?: number;
+
+        /**
+         * How far you can dolly out ( PerspectiveCamera only ).
+         * @default Infinity
+         */
+        maxDistance?: number;
+
+        /**
+         * How far you can zoom in ( OrthographicCamera only ).
+         * @default 0
+         */
+        minZoom?: number;
+
+        /**
+         * How far you can zoom out ( OrthographicCamera only ).
+         * @default Infinity
+         */
+        maxZoom?: number;
+
+        /**
+         * How far you can orbit vertically, lower limit.
+         * Range is 0 to Math.PI radians.
+         * @default 0
+         */
+        minPolarAngle?: number;
+
+        /**
+         * How far you can orbit vertically, upper limit.
+         * Range is 0 to Math.PI radians.
+         * @default Math.PI.
+         */
+        maxPolarAngle?: number;
+
+        /**
+         * How far you can orbit horizontally, lower limit.
+         * If set, the interval [ min, max ]
+         * must be a sub-interval of [ - 2 PI, 2 PI ],
+         * with ( max - min < 2 PI ).
+         * @default Infinity
+         */
+        minAzimuthAngle?: number;
+
+        /**
+         * How far you can orbit horizontally, upper limit.
+         * If set, the interval [ min, max ] must be a sub-interval
+         * of [ - 2 PI, 2 PI ], with ( max - min < 2 PI ).
+         * @default Infinity
+         */
+        maxAzimuthAngle?: number;
+
+        /**
+         * Set to true to enable damping (inertia), which can
+         * be used to give a sense of weight to the controls.
+         * Note that if this is enabled, you must call
+         * .update () in your animation loop.
+         * @default false
+         */
+        enableDamping?: boolean;
+
+        /**
+         * The damping inertia used if .enableDamping is set to true.
+         * Note that for this to work,
+         * you must call .update () in your animation loop.
+         * @default 0.05
+         */
+        dampingFactor?: number;
+
+        /**
+         * Enable or disable zooming (dollying) of the camera.
+         * @default true
+         */
+        enableZoom?: boolean;
+
+        /**
+         * Speed of zooming / dollying.
+         * @default 1
+         */
+        zoomSpeed?: number;
+
+        /**
+         * Setting this property to `true` allows to zoom to the cursor's position.
+         * @default false
+         */
+        zoomToCursor?: boolean;
+
+        /**
+         * Enable or disable horizontal and
+         * vertical rotation of the camera.
+         * Note that it is possible to disable a single axis
+         * by setting the min and max of the polar angle or
+         * azimuth angle to the same value, which will cause
+         * the vertical or horizontal rotation to be fixed at that value.
+         * @default true
+         */
+        enableRotate?: boolean;
+
+        /**
+         * Speed of rotation.
+         * @default 1
+         */
+        rotateSpeed?: number;
+
+        /**
+         * Enable or disable camera panning.
+         * @default true
+         */
+        enablePan?: boolean;
+
+        /**
+         * Speed of panning.
+         * @default 1
+         */
+        panSpeed?: number;
+
+        /**
+         * Defines how the camera's position is translated when panning.
+         * If true, the camera pans in screen space. Otherwise,
+         * the camera pans in the plane orthogonal to the camera's
+         * up direction. Default is true for OrbitControls; false for MapControls.
+         * @default true
+         */
+        screenSpacePanning?: boolean;
+
+        /**
+         * How fast to pan the camera when the keyboard is used.
+         * Default is 7.0 pixels per keypress.
+         * @default 7
+         */
+        keyPanSpeed?: number;
+
+        /**
+         * Set to true to automatically rotate around the target.
+         * Note that if this is enabled, you must call .update() in your animation loop. If you want the auto-rotate speed
+         * to be independent of the frame rate (the refresh rate of the display), you must pass the time `deltaTime`, in
+         * seconds, to .update().
+         */
+        autoRotate?: boolean;
+
+        /**
+         * How fast to rotate around the target if .autoRotate is true.
+         * Default is 2.0, which equates to 30 seconds per orbit at 60fps.
+         * Note that if .autoRotate is enabled, you must call
+         * .update () in your animation loop.
+         * @default 2
+         */
+        autoRotateSpeed?: number;
+
+    } ;
     enabled: boolean;
     target: Vector3;
     minDistance: number;
diff --git a/node_modules/expo-three-orbit-controls/build/OrbitControls.js b/node_modules/expo-three-orbit-controls/build/OrbitControls.js
index 5540eb2..a73909c 100644
--- a/node_modules/expo-three-orbit-controls/build/OrbitControls.js
+++ b/node_modules/expo-three-orbit-controls/build/OrbitControls.js
@@ -39,39 +39,39 @@ export class OrbitControls extends EventDispatcher {
         // "target" sets the location of focus, where the object orbits around
         this.target = new Vector3();
         // How far you can dolly in and out ( PerspectiveCamera only )
-        this.minDistance = 0;
-        this.maxDistance = Infinity;
+        this.minDistance = object.minDistance || 0;
+        this.maxDistance = object.maxDistance || Infinity;
         // How far you can zoom in and out ( OrthographicCamera only )
-        this.minZoom = 0;
-        this.maxZoom = Infinity;
+        this.minZoom = object.minZoom || 0;
+        this.maxZoom = object.maxZoom || Infinity;
         // How far you can orbit vertically, upper and lower limits.
         // Range is 0 to Math.PI radians.
-        this.minPolarAngle = 0; // radians
-        this.maxPolarAngle = Math.PI; // radians
+        this.minPolarAngle = object.minPolarAngle || 0; // radians
+        this.maxPolarAngle = object.maxPolarAngle|| Math.PI; // radians
         // How far you can orbit horizontally, upper and lower limits.
         // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
         this.minAzimuthAngle = -Infinity; // radians
         this.maxAzimuthAngle = Infinity; // radians
         // Set to true to enable damping (inertia)
         // If damping is enabled, you must call controls.update() in your animation loop
-        this.enableDamping = false;
-        this.dampingFactor = 0.05;
+        this.enableDamping = object.enableDamping|| false;
+        this.dampingFactor = object.dampingFactor || 0.05;
         // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
         // Set to false to disable zooming
-        this.enableZoom = true;
-        this.zoomSpeed = 1.0;
+        this.enableZoom = object.enableZoom ||  true;
+        this.zoomSpeed = object.zoomSpeed || 1.0;
         // Set to false to disable rotating
-        this.enableRotate = true;
-        this.rotateSpeed = 1.0;
+        this.enableRotate = object.enableRotate || true;
+        this.rotateSpeed = object.rotateSpeed || 1.0;
         // Set to false to disable panning
-        this.enablePan = true;
-        this.panSpeed = 1.0;
+        this.enablePan = object.enablePan || false;
+        this.panSpeed = object.panSpeed || 1.0;
         this.screenSpacePanning = false; // if true, pan in screen-space
         this.keyPanSpeed = 7.0; // pixels moved per arrow key push
         // Set to true to automatically rotate around the target
         // If auto-rotate is enabled, you must call controls.update() in your animation loop
-        this.autoRotate = false;
-        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
+        this.autoRotate = object.autoRotate || false;
+        this.autoRotateSpeed = object.autoRotateSpeed || 2.0; // 30 seconds per round when fps is 60
         // Set to false to disable use of the keys
         this.enableKeys = true;
         // The four arrow keys
@@ -354,6 +354,8 @@ export class OrbitControls extends EventDispatcher {
             const dx = touches[0].pageX - touches[1].pageX;
             const dy = touches[0].pageY - touches[1].pageY;
             const distance = Math.sqrt(dx * dx + dy * dy);
+            // fix: scale went infinity/zero/Nan when distance is zero
+            if (distance === 0) return;
             this.dollyEnd.set(0, distance);
             this.dollyDelta.set(0, this.dollyEnd.y / this.dollyStart.y ** this.zoomSpeed);
             this.dollyIn(this.dollyDelta.y);
@@ -515,6 +517,7 @@ export class OrbitControls extends EventDispatcher {
             if (this.enabled === false)
                 return;
             (_b = (_a = event).preventDefault) === null || _b === void 0 ? void 0 : _b.call(_a);
+            
             switch (event.touches.length) {
                 case 1:
                     switch (this.touches.ONE) {
@@ -534,6 +537,7 @@ export class OrbitControls extends EventDispatcher {
                             this.state = STATE.NONE;
                     }
                     break;
+                // multi touches not working on granted start
                 case 2:
                     switch (this.touches.TWO) {
                         case TOUCH.DOLLY_PAN:
@@ -631,7 +635,7 @@ export class OrbitControls extends EventDispatcher {
             const offset = new Vector3();
             // so camera.up is the orbit axis
             const quat = new Quaternion().setFromUnitVectors(this.object.up, new Vector3(0, 1, 0));
-            const quatInverse = quat.clone().inverse();
+            const quatInverse = quat.clone().invert();
             const lastPosition = new Vector3();
             const lastQuaternion = new Quaternion();
             return () => {
diff --git a/node_modules/expo-three-orbit-controls/build/OrbitControlsView.js b/node_modules/expo-three-orbit-controls/build/OrbitControlsView.js
index c1c0d43..e97734c 100644
--- a/node_modules/expo-three-orbit-controls/build/OrbitControlsView.js
+++ b/node_modules/expo-three-orbit-controls/build/OrbitControlsView.js
@@ -13,6 +13,8 @@ function polyfillEventTouches(nativeEvent) {
     }
     return nativeEvent;
 }
+
+const TOUCH_THRESHOLD = 20;
 const OrbitControlsView = React.forwardRef(({ camera, ...props }, ref) => {
     var _a;
     const [size, setSize] = React.useState(null);
@@ -42,11 +44,20 @@ const OrbitControlsView = React.forwardRef(({ camera, ...props }, ref) => {
             return (_a = controls) === null || _a === void 0 ? void 0 : _a.onTouchEnd(polyfill);
         }
         return PanResponder.create({
-            onStartShouldSetPanResponder: (evt, gestureState) => true,
-            onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
+            onStartShouldSetPanResponder: (evt, gestureState) => {
+                // fix multi touchs are not detected on start by adding little "delay" 
+                // in sensing touchs
+                const { dx, dy } = gestureState;
+                return (Math.abs(dx) > TOUCH_THRESHOLD) || (Math.abs(dy) > TOUCH_THRESHOLD);
+                
+            },
+            onStartShouldSetPanResponderCapture: (evt, gestureState) => {
+                const { dx, dy } = gestureState;
+                return (Math.abs(dx) > TOUCH_THRESHOLD) || (Math.abs(dy) > TOUCH_THRESHOLD);
+            },
             onMoveShouldSetPanResponder: (evt, gestureState) => true,
             onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,
-            onPanResponderGrant({ nativeEvent }) {
+            onPanResponderGrant({ nativeEvent }, gestureState) {
                 var _a;
                 return (_a = controls) === null || _a === void 0 ? void 0 : _a.onTouchStart(nativeEvent);
             },
